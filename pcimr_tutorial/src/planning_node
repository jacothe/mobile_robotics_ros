#!/usr/bin/env python3

import rospy
import numpy as np
import os
from threading import Lock
from random import randrange

from std_msgs.msg import String
from geometry_msgs.msg import Point, Quaternion
from nav_msgs.msg import OccupancyGrid, Path
from visualization_msgs.msg import Marker
from graph_node import Graph_Node
from node_outputs import create_line_strip, create_marker, build_path_message


def target_invalid(target, map):
    return target is None or map[target[0], target[1]] != 0

def set_random_target(shape):
    return (randrange(shape[0]), randrange(shape[1]))


def is_valid_location(map, location):
    return map[location[0], location[1]] == 0


def expand_node(node, map, target):
    MOVE_IDS = 'NWSE'
    MOVES = [np.array([0, 1]), # Up
            np.array([-1, 0]), # Left
            np.array([0, -1]),   # Down
            np.array([1, 0])]    # Right
    new_nodes = []
    for index, moves in enumerate(MOVE_IDS):
        new_location = (node.x + MOVES[index][0], node.y + MOVES[index][1])
        if is_valid_location(map, new_location):
            new_nodes.append(Graph_Node(new_location, target))

    return new_nodes

def get_closest_node(node_array):
    lowest_cost = 1000
    nodes = []
    for node in node_array:
        if node.cost < lowest_cost:
            lowest_cost = node.cost
    for node in node_array:
        if node.cost == lowest_cost:
            return node
    return nodes

def pop_node_from_frontier(node_to_pop, frontier):
    return [node for node in frontier if node.id != node_to_pop.id]

def nodes_contain_target(nodes, target):
    for node in nodes:
        if node.x == target[0] and node.y == target[1]:
            return node
    return None


def find_adjacent_node(nodes, target_node):
    candidates = []
    for node in nodes:
        if (abs(node.x - target_node.x) + abs(node.y - target_node.y)) == 1:
            return node

def build_path_from_nodes(robot_pos, target_node, explored_nodes, map):
    current_node = target_node
    starting_node = Graph_Node(robot_pos, target_node.location)
    node_path = [target_node]
    while current_node != starting_node:
        current_node = find_adjacent_node(explored_nodes, current_node)
        node_path.insert(0, current_node)

    return node_path

def remove_explored_nodes(explored_nodes, new_nodes):
    unexplored_nodes = []
    for node in new_nodes:
        explored = False
        for explored_node in explored_nodes:
            if explored_node == node:
                explored = True
        if not explored:
            unexplored_nodes.append(node)

    return unexplored_nodes


def build_path(robot_pos, map, target):
    first_node = Graph_Node(robot_pos, target)
    target_found = None
    frontier = [first_node]
    explored_nodes = []
    target_node = None
    while not target_found:
        closest_node = get_closest_node(frontier)
        frontier = pop_node_from_frontier(closest_node, frontier)
        new_nodes = expand_node(closest_node, map, target)
        explored_nodes.append(closest_node)
        unexplored_nodes = remove_explored_nodes(explored_nodes, new_nodes)
        frontier.extend(unexplored_nodes)
        target_node = nodes_contain_target(new_nodes, target)
        if target_node is not None:
            target_found = True

    return build_path_from_nodes(robot_pos, target_node, explored_nodes, map)

class PlanningNode:
    """
    A node which implements the A* graph search for finding a route in a discretized 2d grid.
    """

    def __init__(self, num_sensors: int = 4):
        """

        """
        # Initialize member variables
        self.sim_lock = Lock()
        # get an instance of RosPack with the default search paths

        # Initialize Publishers
        self.pub_path = rospy.Publisher('/global_path', Path, queue_size=10)
        self.pub_robot_path = rospy.Publisher('/visualization/plan', Marker, queue_size=10)
        self.pub_goal_marker = rospy.Publisher('/visualization/robot_pos', Marker, queue_size=10)

        # Initialize Subscribers
        self.robot_pos = rospy.Subscriber('/robot_pos', Point, self.receive_robot_pos)
        self.robot_map = rospy.Subscriber('/map', OccupancyGrid, self.receive_map)

        self.target_goal = None

        self.map = None;
        self.mapInit = False


        self.robot_pos = None
        self.path_built = False

    def build_target(self):
        target = None
        shape = np.shape(self.map)
        while target_invalid(target, self.map):
            target = set_random_target(shape)
        marker = create_marker(target)
        self.pub_goal_marker.publish(marker)
        self.target_goal = target

    def receive_map(self, msg):
        if not self.mapInit:
            self.mapInit = True
            self.mapWidth = msg.info.width
            self.mapHeight = msg.info.height
            self.map = np.transpose(np.asarray(msg.data, dtype=np.int8).reshape(msg.info.width, msg.info.height))
            self.build_target()

    def receive_robot_pos(self, pos):
        """
        """
        self.sim_lock.acquire()
        self.robot_pos = (int(pos.x), int(pos.y))
        if self.target_goal and pos.x == self.target_goal[0] and pos.y == self.target_goal[1]:
            self.build_target()
            self.path_built = False
        if self.mapInit and self.target_goal and not self.path_built:
            path = build_path(self.robot_pos, self.map, self.target_goal)
            linestrip = create_line_strip(path)
            self.pub_robot_path.publish(linestrip)
            self.path_built = True
            path_msg = build_path_message(path)
            self.pub_path.publish(path_msg)
        self.sim_lock.release()

    def run(self, rate: float = 1):
        """
        """
        while not rospy.is_shutdown():
            pass


if __name__ == "__main__":
    rospy.init_node('planning_node')

    simple_sim_node = PlanningNode()
    simple_sim_node.run()
